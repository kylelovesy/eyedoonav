// __tests__/repositories/firestore/firestore-base-project-repository.spec.ts

import { FirestoreBaseProjectRepository } from '@/repositories/firestore/firestore-base-project-repository';
import { BaseProject, BaseProjectInput, defaultBaseProject } from '@/domain/project/project.schema';
import { doc, getDoc, setDoc, updateDoc, collection } from 'firebase/firestore';
import { ok } from '@/domain/common/result';

// Mock firebase config first
jest.mock('@/config/firebaseConfig', () => ({
  db: {},
  storage: {},
}));

// Mock firebase/firestore
jest.mock('firebase/firestore', () => ({
  doc: jest.fn(),
  getDoc: jest.fn(),
  setDoc: jest.fn(),
  updateDoc: jest.fn(),
  collection: jest.fn(),
}));

const mockGetDoc = getDoc as jest.Mock;
const mockSetDoc = setDoc as jest.Mock;
const mockUpdateDoc = updateDoc as jest.Mock;
const mockCollection = collection as jest.Mock;
const mockDoc = doc as jest.Mock;

describe('FirestoreBaseProjectRepository', () => {
  let repository: FirestoreBaseProjectRepository;
  const projectId = 'test-project-id';
  const userId = 'user-123';
  const mockDocRef = { id: 'mock-doc-ref' };
  const mockProjectInput: BaseProjectInput = {
    projectName: 'Test Project',
    eventDate: new Date(),
    personAName: { firstName: 'John', lastName: 'Doe' },
    personBName: { firstName: 'Jane', lastName: 'Smith' },
    email: 'john@example.com',
    phone: '+1234567890',
  };
  const mockProject: BaseProject = {
    ...defaultBaseProject(projectId, userId, 'Test Project'),
    projectName: 'Test Project',
  };

  beforeEach(() => {
    jest.clearAllMocks();
    repository = new FirestoreBaseProjectRepository();
    mockDoc.mockReturnValue(mockDocRef);
    mockCollection.mockReturnValue({ id: 'projects-collection' });
  });

  describe('getById', () => {
    it('should return a project if document exists', async () => {
      mockGetDoc.mockResolvedValue({
        exists: () => true,
        data: () => mockProject,
      });

      const result = await repository.getById(projectId);

      expect(mockDoc).toHaveBeenCalledWith({}, `projects/${projectId}`);
      expect(mockGetDoc).toHaveBeenCalledWith(mockDocRef);
      expect(result).toEqual(ok(mockProject));
    });
  });

  describe('create', () => {
    it('should create a project document successfully', async () => {
      const autoGeneratedDocRef = { id: 'auto-generated-id' };
      mockDoc
        .mockReturnValueOnce(autoGeneratedDocRef) // For doc(collectionRef)
        .mockReturnValueOnce(mockDocRef); // For getDoc after creation

      mockGetDoc.mockResolvedValue({
        exists: () => true,
        data: () => mockProject,
      });

      const result = await repository.create(userId, mockProjectInput);

      expect(mockCollection).toHaveBeenCalledWith({}, 'projects');
      expect(mockDoc).toHaveBeenCalledWith({ id: 'projects-collection' });
      expect(mockSetDoc).toHaveBeenCalled();
      expect(result.success).toBe(true);
    });
  });

  describe('update', () => {
    it('should update a project document successfully', async () => {
      mockUpdateDoc.mockResolvedValue(undefined);
      const updates = { projectName: 'New Name' };

      const result = await repository.update(projectId, updates);

      expect(mockDoc).toHaveBeenCalledWith({}, `projects/${projectId}`);
      expect(mockUpdateDoc).toHaveBeenCalledWith(mockDocRef, updates);
      expect(result).toEqual(ok(undefined));
    });
  });
});
